> **🍕博客主页：️[自信不孤单](https://blog.csdn.net/czh1592272237)**
>
> **🍬文章专栏：[C语言](https://blog.csdn.net/czh1592272237/category_12209876.html)**
>
> **🍚代码仓库：[破浪晓梦](https://gitee.com/polang-xiaomeng/study_c)**
>
> **🍭欢迎关注：欢迎大家点赞收藏+关注**

# 通讯录——动态版

[toc]

---

# 前言

> **温馨提示：**
> **==大家在看这篇文章前，请先看完上一篇文章[通讯录——静态版](https://blog.csdn.net/czh1592272237/article/details/129774050?spm=1001.2014.3001.5501)，这篇文章是对上一篇文章所实现静态版通讯录的升级。==**

> 在上一篇文章中，我们已经实现了通讯录的静态版本。我们发现静态通讯录存在的一个最大问题就是无法自动扩容，当信息存满了，就无法继续添加联系人。就此问题，我们对之前的静态版本升级为动态版本。

# 对静态版的修改

## 1. 通讯录结构体的声明

==静态版本：==

```c
typedef struct Contact
{
	PeopleInfo data[MAX];//定义数组用来存放联系人信息
	int sz;//记录通讯录中有效信息的个数
}Contact;
```

==动态版本：==

```c
typedef struct Contact
{
	PeopleInfo* data;//data指向存放数据的空间
	int sz;//记录通讯录中有效信息的个数
	int capacity;//记录通讯录当前的容量
}Contact;
```

> 这里将固定大小的PeopleInfo类型的数组改为了PeopleInfo*类型的指针，用capacity来记录指针指向的动态开辟空间所能容纳的元素个数。

## 2. 初始化通讯录

==静态版本：==

```c
void InitContact(Contact* pc)
{
	pc->sz = 0;
	memset(pc->data, 0, sizeof(pc->data));
}
```

==动态版本：==

```c
void InitContact(Contact* pc)
{
	pc->data = (PeopleInfo*)calloc(DEFAULT_SZ, sizeof(PeopleInfo));
	if (pc->data == NULL)
	{
		perror("初始化失败");
		return;
	}
	pc->sz = 0;
	pc->capacity = DEFAULT_SZ;
}
```

> - 这里使用calloc函数在堆区动态开辟一块空间，并初始化为0。
> - 在contact.h头文件中宏定义了DEFAYLT_SZ常量表示默认开辟元素个数，在此定义DEFAYLT_SZ的值为3。
> - 若开辟失败，则显示失败信息。
> - 把容量capacity置为默认元素个数DEFAYLT_SZ。

## 3. 添加联系人

==静态版本：==

```c
void Add(Contact* pc)
{
	if (pc->sz == MAX)
	{
		printf("通讯录已满，无法继续填入信息\n");
		return;
	}
	printf("请输入姓名:>");
	scanf("%s", pc->data[pc->sz].name);
	printf("请输入性别:>");
	scanf("%s", pc->data[pc->sz].sex);
	printf("请输入年龄:>");
	scanf("%d", &(pc->data[pc->sz].age));
	printf("请输入电话号:>");
	scanf("%s", pc->data[pc->sz].tele);
	printf("请输入住址:>");
	scanf("%s", pc->data[pc->sz].addr);
	pc->sz++;
	printf("添加成功\n");
}
```

==动态版本：==

```c
static int CheckCapacity(Contact* pc)
{
	if (pc->sz == pc->capacity)
	{
		PeopleInfo* str = (PeopleInfo*)realloc(pc->data, (pc->capacity + INC_SZ) * sizeof(PeopleInfo));
		if (str != NULL)
		{
			pc->data = str;
			pc->capacity += INC_SZ;
		}
		else
		{
			printf("内存不足，通讯录扩容失败\n");
			return -1;
		}
		printf("通讯录扩容成功，当前容量为%d\n", pc->capacity);
	}
	return 1;
}

void Add(Contact* pc)
{
	if (CheckCapacity(pc) == -1)
	{
		return;
	}
	printf("请输入姓名:>");
	scanf("%s", pc->data[pc->sz].name);
	printf("请输入性别:>");
	scanf("%s", pc->data[pc->sz].sex);
	printf("请输入年龄:>");
	scanf("%d", &(pc->data[pc->sz].age));
	printf("请输入电话号:>");
	scanf("%s", pc->data[pc->sz].tele);
	printf("请输入住址:>");
	scanf("%s", pc->data[pc->sz].addr);
	pc->sz++;
	printf("添加成功\n");
}
```

> 在动态版本中，封装了一个check_capacity函数，专门用于检查通讯录是否满额，如果满了就会自动扩容通讯录，每次扩容增加INC_SZ（宏定义此处值为5）个元素的空间 。

**==注意：==**

> 使用realloc函数时，不能直接用data来接收realloc函数的返回值，如果开辟空间失败，那么原先data所指向的空间就会丢失。因此，需要一个临时变量来接收，判断空间开辟成功后，再让data指向这块空间。

## 4. 销毁通讯录

```c
void Destroy(Contact* pc)
{
	free(pc->data);
	pc->data = NULL;
	pc->capacity = 0;
	pc->sz = 0;
	printf("释放内存成功\n");
}
```

> 在动态通讯录中，我们在使用完堆上开辟的空间后需要主动去释放，防止内存泄漏。要实现此功能，可以直接使用free释放掉空间，同时也要将指针置空。 

==这就是动态版本通讯录的实现，其他函数功能实现同静态版通讯录。==

# 完整源码

==tect.c文件==

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include "contact.h"

enum Optition
{
	EXIT,
	ADD,
	DEL,
	SEARCH,
	MODIFY,
	SHOW,
	SORT
};

static void menu()
{
	printf("********************************\n");
	printf("***    1. add     2. del     ***\n");
	printf("***    3. search  4. modify  ***\n");
	printf("***    5. show    6. sort    ***\n");
	printf("***    0. exit               ***\n");
	printf("********************************\n");
}



int main()
{

	int input = 0;
	Contact con;
	//初始化通讯录
	InitContact(&con);
	do
	{
		menu();
		printf("请输入操作选项:>");
		scanf("%d", &input);
		switch (input)
		{
		case ADD:
			Add(&con);
			break;
		case DEL:
			Del(&con);
			break;
		case SEARCH:
			Search(&con);
			break;
		case MODIFY:
			Modify(&con);
			break;
		case SHOW:
			Show(&con);
			break;
		case SORT:
			Sort(&con);
			break;
		case EXIT:
			Destroy(&con);
			printf("退出通讯录\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (input);

	return 0;
}
```

==contact.h文件==

```c
#pragma once

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_NAME 20
#define MAX_SEX 5
#define MAX_TELE 12
#define MAX_ADDR 40
#define DEFAULT_SZ 3    //默认大小
#define INC_SZ 5    //扩容大小

//描述一个人的信息
typedef struct PeopleInfo
{
	char name[MAX_NAME];
	char sex[MAX_SEX];
	int age;
	char tele[MAX_TELE];
	char addr[MAX_ADDR];
}PeopleInfo;

//通讯录
typedef struct Contact
{
	PeopleInfo* data;//data指向存放数据的空间
	int sz;//记录通讯录中有效信息的个数
	int capacity;//记录通讯录当前的容量
}Contact;

//初始化通讯录
void InitContact(Contact* pc);
//添加联系人信息
void Add(Contact* pc);
//删除联系人信息
void Del(Contact* pc);
//显示联系人信息
void Show(Contact* pc);
//查找联系人信息
void Search(const Contact* pc);
//修改联系人信息
void Modify(Contact* pc);
//按名字排序通讯录
void Sort(Contact* pc);
//销毁通讯录
void Destroy(Contact* pc);
```

==contact.c文件==

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include "contact.h"

void InitContact(Contact* pc)
{
	pc->data = (PeopleInfo*)calloc(DEFAULT_SZ, sizeof(PeopleInfo));
	if (pc->data == NULL)
	{
		perror("初始化失败");
		return;
	}
	pc->sz = 0;
	pc->capacity = DEFAULT_SZ;
}

void Destroy(Contact* pc)
{
	free(pc->data);
	pc->data = NULL;
	pc->capacity = 0;
	pc->sz = 0;
	printf("释放内存成功\n");
}


static int CheckCapacity(Contact* pc)
{
	if (pc->sz == pc->capacity)
	{
		PeopleInfo* str = (PeopleInfo*)realloc(pc->data, (pc->capacity + INC_SZ) * sizeof(PeopleInfo));
		if (str != NULL)
		{
			pc->data = str;
			pc->capacity += INC_SZ;
		}
		else
		{
			printf("内存不足，通讯录扩容失败\n");
			return -1;
		}
		printf("通讯录扩容成功，当前容量为%d\n", pc->capacity);
	}
	return 1;
}

void Add(Contact* pc)
{
	if (CheckCapacity(pc) == -1)
	{
		return;
	}
	printf("请输入姓名:>");
	scanf("%s", pc->data[pc->sz].name);
	printf("请输入性别:>");
	scanf("%s", pc->data[pc->sz].sex);
	printf("请输入年龄:>");
	scanf("%d", &(pc->data[pc->sz].age));
	printf("请输入电话号:>");
	scanf("%s", pc->data[pc->sz].tele);
	printf("请输入住址:>");
	scanf("%s", pc->data[pc->sz].addr);
	pc->sz++;
	printf("添加成功\n");
}

void Show(Contact* pc)
{
	if (pc->sz == 0)
	{
		printf("通讯录为空\n");
		return;
	}
	printf("%-20s%-10s%-20s%-20s%-30s\n", "姓名", "性别", "年龄", "电话", "地址");
	for (int i = 0; i < pc->sz; i++)
	{
		printf("%-20s%-10s%-20d%-20s%-30s\n",
			pc->data[i].name, pc->data[i].sex,
			pc->data[i].age, pc->data[i].tele, pc->data[i].addr);
	}
}

//查找联系人姓名
static int Find(const Contact* pc, const char name[])
{
	int i = 0;
	for (i = 0; i < pc->sz; i++)
	{
		if (strcmp(name, pc->data[i].name) == 0)
		{
			return i;
		}
	}
	return -1;
}

void Del(Contact* pc)
{
	char name[MAX_NAME] = {0};
	int ret = 0, i = 0;
	printf("请输入要删除人的姓名:>");
	scanf("%s", name);
	ret = Find(pc, name);
	if (ret == -1)
	{
		printf("删除失败，该联系人不存在\n");
		return;
	}
	else
	{
		for (i = ret; i < pc->sz-1; i++)
		{
			pc->data[i] = pc->data[i + 1];
		}
		pc->sz--;
		printf("删除成功\n");
	}
}


void Search(const Contact* pc)
{
	char name[MAX_NAME] = { 0 };
	int ret = 0;
	printf("请输入要查找人的名字:>");
	scanf("%s", name);
	ret = Find(pc, name);
	if (ret == -1)
	{
		printf("该联系人不存在\n");
		return;
	}
	else
	{
		printf("%-20s%-10s%-20s%-20s%-30s\n", "姓名", "性别", "年龄", "电话", "地址");
		printf("%-20s%-10s%-20d%-20s%-30s\n", pc->data[ret].name, pc->data[ret].sex,
			pc->data[ret].age, pc->data[ret].tele, pc->data[ret].addr);
	}
}

void Modify(Contact* pc)
{
	char name[MAX_NAME] = { 0 };
	int ret = 0;
	printf("请输入要修改人的姓名:>");
	scanf("%s", name);
	ret = Find(pc, name);
	if (ret == -1)
	{
		printf("该联系人不存在\n");
		return;
	}
	else
	{
		printf("请输入姓名:>");
		scanf("%s", pc->data[ret].name);
		printf("请输入性别:>");
		scanf("%s", pc->data[ret].sex);
		printf("请输入年龄:>");
		scanf("%d", &(pc->data[ret].age));
		printf("请输入电话号:>");
		scanf("%s", pc->data[ret].tele);
		printf("请输入住址:>");
		scanf("%s", pc->data[ret].addr);
		printf("修改成功\n");
	}
}

int compare_name(const void* p1, const void* p2)
{
	return strcmp(((PeopleInfo*)p1)->name, ((PeopleInfo*)p2)->name);
}

void Sort(Contact* pc)
{
	qsort(pc->data, pc->sz, sizeof(PeopleInfo), compare_name);
	printf("排序成功\n");
}
```

==到此，关于《通讯录——动态版》的内容就结束了
感谢大家的观看
创作不易，如果对您有帮助，请一键三连
您的支持就是我创作最大的动力！！！==