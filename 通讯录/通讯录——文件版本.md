> **🍕博客主页：️[自信不孤单](https://blog.csdn.net/czh1592272237)**
>
> **🍬文章专栏：[C语言](https://blog.csdn.net/czh1592272237/category_12209876.html)**
>
> **🍚代码仓库：[破浪晓梦](https://gitee.com/polang-xiaomeng/study_c)**
>
> **🍭欢迎关注：欢迎大家点赞收藏+关注**

# 通讯录——文件版

[toc]

---

# 前言

> 在之前的文章，我们已经完成了通讯录的静态版和动态版，在此基础上我们来继续对通讯录加以完善。

==**注：如果大家对于这篇《通讯录——文件版》看的不是很懂的话，可以先看看我之前写的《[通讯录——静态版](https://blog.csdn.net/czh1592272237/article/details/129774050?spm=1001.2014.3001.5501)》和《[通讯录——动态版](https://blog.csdn.net/czh1592272237/article/details/129781883?spm=1001.2014.3001.5501)》，这样再来看这篇文章就会很轻松。**==

# 对动态版的修改

> 在动态版的基础上，我们需要把通讯录里的信息在程序结束时存到文件中，并在程序开始时将文件中的信息再次加载到data指向的空间中。这样通过对文件的操作就实现了将信息存储到文件中进行保存，并在重新执行程序时还能读到之前存入的信息。

## 1. 初始化函数的实现


> 初始化函数是在静态版和动态版实现的基础上，新增了加载文件到通讯录的操作。

- 首先使用fopen函数以二进制读（rb）的形式打开我们的文件。如果打开成功，fopen函数就会返回一个FILE*类型的文本信息区的地址；如果打开失败，则会返回NULL。
- 然后使用fread函数来从文件中读取数据。一次读一个PeoInfo类型的数据到tmp中，读取成功时，就会返回读取数据的个数，在这里每次读取成功返回1，当没有数据可以读就返回0，所以这里可以通过while循环将数据一条一条的读入到data指向的内存中。
- 最后使用fclose函数关闭文件，并把文件指针置为NULL。

```c
void LoadContact(Contact* pc)
{
	//打开文件
	FILE* pf = fopen("test.dat", "rb");
	if (NULL == pf)
	{
		perror("LoadContact::fopen");
		return;
	}
	//读文件
	PeopleInfo tmp = { 0 };
	while (fread(&tmp, sizeof(PeopleInfo), 1, pf))
	{
		CheckCapacity(pc);
		pc->data[pc->sz] = tmp;
		(pc->sz)++;
	}
	//关闭文件
	fclose(pf);
	pf = NULL;
}

void InitContact(Contact* pc)
{
	pc->data = (PeopleInfo*)calloc(DEFAULT_SZ, sizeof(PeopleInfo));
	if (pc->data == NULL)
	{
		perror("InitContact::calloc");
		return;
	}
	pc->sz = 0;
	pc->capacity = DEFAULT_SZ;
	//加载文件的信息到通讯录
	LoadContact(pc);
}
```


## 2. 保存通讯录信息到文件

> 在我们完成对的操作时，就可以在结束程序时将通讯录的信息保存到文件中。

- 首先使用fopen函数以二进制写（wb）的形式打开我们的文件。如果打开成功，fopen函数就会返回一个FILE*类型的文本信息区的地址；如果打开失败，则会返回NULL。
- 然后使用fwrite函数来从文件中读取数据。可以使用for循环将data指向空间的sz个Peopleinfo类型数据一条一条的写入到文件中。
- 最后使用fclose函数关闭文件，并把文件指针置为NULL。

```c
  void Save(Contact* pc)
{
	//打开文件
	FILE* pf = fopen("test.dat", "wb");
	if (NULL == pf)
	{
		perror("Save::fopen");
		return;
	}
	//写文件
	int i = 0;
	for (i = 0; i < pc->sz; i++)
	{
		fwrite((pc->data) + i, sizeof(PeopleInfo), 1, pf);
	}
	//关闭文件
	fclose(pf);
	pf = NULL;
	printf("保存成功\n");
}
```

# 完整源码

==tect.c文件==

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include "contact.h"

enum Optition
{
	EXIT,
	ADD,
	DEL,
	SEARCH,
	MODIFY,
	SHOW,
	SORT
};

static void menu()
{
	printf("********************************\n");
	printf("***    1. add     2. del     ***\n");
	printf("***    3. search  4. modify  ***\n");
	printf("***    5. show    6. sort    ***\n");
	printf("***    0. exit               ***\n");
	printf("********************************\n");
}



int main()
{

	int input = 0;
	Contact con;
	//初始化通讯录
	InitContact(&con);
	do
	{
		menu();
		printf("请输入操作选项:>");
		scanf("%d", &input);
		switch (input)
		{
		case ADD:
			Add(&con);
			break;
		case DEL:
			Del(&con);
			break;
		case SEARCH:
			Search(&con);
			break;
		case MODIFY:
			Modify(&con);
			break;
		case SHOW:
			Show(&con);
			break;
		case SORT:
			Sort(&con);
			break;
		case EXIT:
			Save(&con);
			Destroy(&con);
			printf("退出通讯录\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (input);

	return 0;
}
```

==contact.h文件==

```c
#pragma once

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_NAME 20
#define MAX_SEX 5
#define MAX_TELE 12
#define MAX_ADDR 40
#define DEFAULT_SZ 3    //默认大小
#define INC_SZ 5    //扩容大小

//描述一个人的信息
typedef struct PeopleInfo
{
	char name[MAX_NAME];
	char sex[MAX_SEX];
	int age;
	char tele[MAX_TELE];
	char addr[MAX_ADDR];
}PeopleInfo;

//通讯录
typedef struct Contact
{
	PeopleInfo* data;//data指向存放数据的空间
	int sz;//记录通讯录中有效信息的个数
	int capacity;//记录通讯录当前的容量
}Contact;

//初始化通讯录
void InitContact(Contact* pc);
//添加联系人信息
void Add(Contact* pc);
//删除联系人信息
void Del(Contact* pc);
//显示联系人信息
void Show(Contact* pc);
//查找联系人信息
void Search(const Contact* pc);
//修改联系人信息
void Modify(Contact* pc);
//按名字排序通讯录
void Sort(Contact* pc);
//销毁通讯录
void Destroy(Contact* pc);
//保存数据到文件
void Save(Contact* pc);
```

==contact.c文件==

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include "contact.h"

static int CheckCapacity(Contact* pc);

void LoadContact(Contact* pc)
{
	//打开文件
	FILE* pf = fopen("test.dat", "rb");
	if (NULL == pf)
	{
		perror("LoadContact::fopen");
		return;
	}
	//读文件
	PeopleInfo tmp = { 0 };
	while (fread(&tmp, sizeof(PeopleInfo), 1, pf))
	{
		CheckCapacity(pc);
		pc->data[pc->sz] = tmp;
		(pc->sz)++;
	}
	//关闭文件
	fclose(pf);
	pf = NULL;
}

//文件版
void InitContact(Contact* pc)
{
	pc->data = (PeopleInfo*)calloc(DEFAULT_SZ, sizeof(PeopleInfo));
	if (pc->data == NULL)
	{
		perror("InitContact::calloc");
		return;
	}
	pc->sz = 0;
	pc->capacity = DEFAULT_SZ;
	//加载文件的信息到通讯录
	LoadContact(pc);
}

void Destroy(Contact* pc)
{
	free(pc->data);
	pc->data = NULL;
	pc->capacity = 0;
	pc->sz = 0;
	printf("释放内存成功\n");
}


static int CheckCapacity(Contact* pc)
{
	if (pc->sz == pc->capacity)
	{
		PeopleInfo* str = (PeopleInfo*)realloc(pc->data, (pc->capacity + INC_SZ) * sizeof(PeopleInfo));
		if (str != NULL)
		{
			pc->data = str;
			pc->capacity += INC_SZ;
		}
		else
		{
			printf("内存不足，通讯录扩容失败\n");
			return -1;
		}
		printf("通讯录扩容成功，当前容量为%d\n", pc->capacity);
	}
	return 1;
}

void Add(Contact* pc)
{
	if (CheckCapacity(pc) == -1)
	{
		return;
	}
	printf("请输入姓名:>");
	scanf("%s", pc->data[pc->sz].name);
	printf("请输入性别:>");
	scanf("%s", pc->data[pc->sz].sex);
	printf("请输入年龄:>");
	scanf("%d", &(pc->data[pc->sz].age));
	printf("请输入电话号:>");
	scanf("%s", pc->data[pc->sz].tele);
	printf("请输入住址:>");
	scanf("%s", pc->data[pc->sz].addr);
	pc->sz++;
	printf("添加成功\n");
}

void Show(Contact* pc)
{
	if (pc->sz == 0)
	{
		printf("通讯录为空\n");
		return;
	}
	printf("%-20s%-10s%-20s%-20s%-30s\n", "姓名", "性别", "年龄", "电话", "地址");
	for (int i = 0; i < pc->sz; i++)
	{
		printf("%-20s%-10s%-20d%-20s%-30s\n",
			pc->data[i].name, pc->data[i].sex,
			pc->data[i].age, pc->data[i].tele, pc->data[i].addr);
	}
}

//查找联系人姓名
static int Find(const Contact* pc, const char name[])
{
	int i = 0;
	for (i = 0; i < pc->sz; i++)
	{
		if (strcmp(name, pc->data[i].name) == 0)
		{
			return i;
		}
	}
	return -1;
}

void Del(Contact* pc)
{
	char name[MAX_NAME] = {0};
	int ret = 0, i = 0;
	printf("请输入要删除人的姓名:>");
	scanf("%s", name);
	ret = Find(pc, name);
	if (ret == -1)
	{
		printf("删除失败，该联系人不存在\n");
		return;
	}
	else
	{
		for (i = ret; i < pc->sz-1; i++)
		{
			pc->data[i] = pc->data[i + 1];
		}
		pc->sz--;
		printf("删除成功\n");
	}
}


void Search(const Contact* pc)
{
	char name[MAX_NAME] = { 0 };
	int ret = 0;
	printf("请输入要查找人的名字:>");
	scanf("%s", name);
	ret = Find(pc, name);
	if (ret == -1)
	{
		printf("该联系人不存在\n");
		return;
	}
	else
	{
		printf("%-20s%-10s%-20s%-20s%-30s\n", "姓名", "性别", "年龄", "电话", "地址");
		printf("%-20s%-10s%-20d%-20s%-30s\n", pc->data[ret].name, pc->data[ret].sex,
			pc->data[ret].age, pc->data[ret].tele, pc->data[ret].addr);
	}
}

void Modify(Contact* pc)
{
	char name[MAX_NAME] = { 0 };
	int ret = 0;
	printf("请输入要修改人的姓名:>");
	scanf("%s", name);
	ret = Find(pc, name);
	if (ret == -1)
	{
		printf("该联系人不存在\n");
		return;
	}
	else
	{
		printf("请输入姓名:>");
		scanf("%s", pc->data[ret].name);
		printf("请输入性别:>");
		scanf("%s", pc->data[ret].sex);
		printf("请输入年龄:>");
		scanf("%d", &(pc->data[ret].age));
		printf("请输入电话号:>");
		scanf("%s", pc->data[ret].tele);
		printf("请输入住址:>");
		scanf("%s", pc->data[ret].addr);
		printf("修改成功\n");
	}
}

int compare_name(const void* p1, const void* p2)
{
	return strcmp(((PeopleInfo*)p1)->name, ((PeopleInfo*)p2)->name);
}

void Sort(Contact* pc)
{
	qsort(pc->data, pc->sz, sizeof(PeopleInfo), compare_name);
	printf("排序成功\n");
}

void Save(Contact* pc)
{
	//打开文件
	FILE* pf = fopen("test.dat", "wb");
	if (NULL == pf)
	{
		perror("Save::fopen");
		return;
	}
	//写文件
	int i = 0;
	for (i = 0; i < pc->sz; i++)
	{
		fwrite((pc->data) + i, sizeof(PeopleInfo), 1, pf);
	}
	//关闭文件
	fclose(pf);
	pf = NULL;
	printf("保存成功\n");
}
```

==到此，关于《通讯录——动态版》的内容就结束了
感谢大家的观看
创作不易，如果对您有帮助，请一键三连
您的支持就是我创作最大的动力！！！==